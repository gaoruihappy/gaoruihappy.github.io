webpackJsonp([4],{271:function(e,n){e.exports='<h1 id="7vuejs">7种使用VueJs定义一个组件模板的方式</h1>\n<p>有很多种方式可以在在vue中定义组件模板，据我所知至少有7种。</p>\n<ul>\n<li>String</li>\n<li>Template literal</li>\n<li>X-Templates</li>\n<li>Inline</li>\n<li>Render functions</li>\n<li>JSX</li>\n<li>Single page components  </li>\n</ul>\n<p>也许还有更多！</p>\n<p>在这篇文章中我们讲详细介绍每一种的优缺点，以便您了解在任何一张场景下哪种方式是最适合使用的。</p>\n<h2 id="">字符串</h2>\n<p>默认情况下，在js文件里使用一个字符串定义模板。大家都认为使用字符串定义模板是非常难以理解的。除了广泛的浏览器支持之外这种方式没有太多的优点。</p>\n<p>component.js</p>\n<pre><code>Vue.component(\'my-checkbox\', {\ntemplate: `&lt;div class="checkbox-wrapper" @click="check"&gt;&lt;div :class="{ checkbox: true, checked: checked }"&gt;&lt;/div&gt;&lt;div class="title"&gt;{{ title }}&lt;/div&gt;&lt;/div&gt;`,\n  data() {\n    return {\n      checked: false,\n      title: \'Check me\'\n    }\n  },\n  methods: {\n    check() {\n      this.checked = !this.checked;\n    }\n  }\n});\n</code></pre>\n<h2 id="templateliterals">Template literals</h2>\n<p>ES6模板("bcakticks")使得可以通过多行来定义一个模板，这是不能在普通的javascript字符串中使用的。这种方式更易于阅读，且有很多种浏览器支持，尽管在转换为ES5更安全。</p>\n<p>虽然这种方式并不完美，我发现大多数IDEs在语法高亮、格式化tabs、换行等这些方面会带来不便。</p>\n<p>component.js</p>\n<pre><code>Vue.component(\'my-checkbox\', {\n  template: `&lt;div class="checkbox-wrapper" @click="check"&gt;\n               &lt;div :class="{ checkbox: true, checked: checked }"&gt;&lt;/div&gt;\n               &lt;div class="title"&gt;{{ title }}&lt;/div&gt;\n            &lt;/div&gt;`,\n  data() {\n    return {\n      checked: false,\n      title: \'Check me\'\n    }\n  },\n  methods: {\n    check() {\n      this.checked = !this.checked;\n    }\n  }\n});\n</code></pre>\n<h2 id="xtemplates">X-Templates</h2>\n<p>这种方式是在index.html文件中的script标签定义模板。这个script标签使用<code>text-template</code>标记，通过组件定义里的id来引用。</p>\n<p>我喜欢这种在适当的HTML标签中写HTMl，但是缺点是模板与组件定义的其它部分相互分离。</p>\n<p>component.js</p>\n<pre><code>Vue.component(\'my-checkbox\', {\n  template: \'#checkbox-template\',\n  data() {\n    return {\n      checked: false,\n      title: \'Check me\'\n    }\n  },\n  methods: {\n    check() {\n      this.checked = !this.checked;\n    }\n  }\n});\n</code></pre>\n<p>index.html</p>\n<pre><code>&lt;script type="text/x-template" id="checkbox-template"&gt;\n  &lt;div class="checkbox-wrapper" @click="check"&gt;\n    &lt;div :class="{ checkbox: true, checked: checked }"&gt;&lt;/div&gt;\n    &lt;div class="title"&gt;&lt;/div&gt;\n  &lt;/div&gt;\n&lt;/script&gt;\n</code></pre>\n<h2 id="inlinetemplates">Inline Templates</h2>\n<p>通过将<code>inline-template</code>属性添加到组件，向VUE表明其内部内容作为模板，而不是将其做为分布式内容（slots）</p>\n<p>这种方式与x-templates有着同样的缺点，但有一个优点是内容在HTML模板的正确位置，所以模板可以在页面载入时显示，而不是一直到Javascript运行。</p>\n<p>component.js</p>\n<pre><code>Vue.component(\'my-checkbox\', {\n  data() {\n    return {\n      checked: false,\n      title: \'Check me\'\n    }\n  },\n  methods: {\n    check() {\n      this.checked = !this.checked;\n    }\n  }\n});\n</code></pre>\n<p>index.html</p>\n<pre><code>&lt;my-checkbox inline-template&gt;\n  &lt;div class="checkbox-wrapper" @click="check"&gt;\n    &lt;div :class="{ checkbox: true, checked: checked }"&gt;&lt;/div&gt;\n    &lt;div class="title"&gt;&lt;/div&gt;\n  &lt;/div&gt;\n&lt;/my-checkbox&gt;\n</code></pre>\n<h2 id="renderfunctions">Render functions</h2>\n<p>渲染函数需要使用javascript对象定义模板。javascript对象显然是最详尽和抽象多的模板选项。</p>\n<p>然而，其优点是模板更接近编译器，容许访问完整的Javascript功能，而不是指令提供的子集。</p>\n<p>component.js</p>\n<pre><code>Vue.component(\'my-checkbox\', {\n  data() {\n    return {\n      checked: false,\n      title: \'Check me\'\n    }\n  },\n  methods: {\n    check() {\n      this.checked = !this.checked;\n    }\n  },\n  render(createElement) {\n    return createElement(\n      \'div\', {\n        attrs: {\n          \'class\': \'checkbox-wrapper\'\n        },\n        on: {\n          click: this.check\n        }\n      }, [\n        createElement(\n          \'div\', {\n            \'class\': {\n              checkbox: true,\n              checked: this.checked\n            }\n          }\n        ),\n        createElement(\n          \'div\', {\n            attrs: {\n              \'class\': \'title\'\n            }\n          }, [this.title]\n        )\n      ]\n    );\n  }\n});\n</code></pre>\n<h2 id="jsx">JSX</h2>\n<p>最有争议的是使用JSX编写vue模板。有的开发者认为JSX是丑陋的，不直观的，违背了vue的理念。</p>\n<p>JSX首先需要被转换，因为浏览器不能读取。但是，加入需要使用渲染函数，JSX是一种不太抽象的定义模板的方式。</p>\n<p>component.js</p>\n<pre><code>Vue.component(\'my-checkbox\', {\n  data() {\n    return {\n      checked: false,\n      title: \'Check me\'\n    }\n  },\n  methods: {\n    check() {\n      this.checked = !this.checked;\n    }\n  },\n  render() {\n    return &lt;div class="checkbox-wrapper" onClick={ this.check }&gt;\n                 &lt;div class={{ checkbox: true, checked: this.checked }}&gt;&lt;/div&gt;\n                 &lt;div class="title"&gt;{ this.title }&lt;/div&gt;\n               &lt;/div&gt;\n  }\n});\n</code></pre>\n<h2 id="singlefilecomponents">Single File Components</h2>\n<p>只要在构建时使用了合适的构建工具，单文件组件是模板组件的最佳选择。这种方式有两个优点：允许编写标记，同时将所有组件定义在一个文件里。</p>\n<p>这种方式需要转换，且一些IDEs不支持这种文件格式的语法高亮，但是还是优于其它方式。</p>\n<p>component.js</p>\n<pre><code>&lt;template&gt;\n  &lt;div class="checkbox-wrapper" @click="check"&gt;\n    &lt;div :class="{ checkbox: true, checked: checked }"&gt;&lt;/div&gt;\n    &lt;div class="title"&gt;&lt;/div&gt;\n  &lt;/div&gt;\n&lt;/template&gt;\n&lt;script&gt;\n  export default {\n    data() {\n      return {\n        checked: false,\n        title: \'Check me\'\n      }\n    },\n    methods: {\n      check() {\n        this.checked = !this.checked;\n      }\n    }\n  }\n&lt;/script&gt;\n</code></pre>\n<p>你也许认为会有很多其它模板定义方式，因为你可以使用像Pug这种模板预处理器。</p>\n<p>哪种方式是最好的呢？</p>\n<p>当然没有哪一种方式是最完美的，需要根据使用场景来判断。我认为大多数开发者会意识到所有的可能性，并将其做为Vue.js工具栏的一个工具。</p>'}});