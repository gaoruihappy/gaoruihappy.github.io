webpackJsonp([5],{270:function(e,t){e.exports='<h1 id="react">揭开React风靡前端开发领域的面纱</h1>\n<p>[^本文的重点是React受欢迎的原因，而不是与其他框架或库进行比较]: </p>\n<p>以下是React如此迅速流行的几个原因：</p>\n<p>使用DOM API成本较大。React使开发人员能够使用比真实浏览器更友好的虚拟浏览器。React的虚拟浏览器就像开发者和真实浏览器之间的代理一样。</p>\n<p>React允许开发人员声明式地描述UI并给界面状态建模。这意味着开发者只需通过一个最终的状态来描述页面，而不必一步步的处理界面上发生的交互。当前的状态发生改变时，React会相应地更新UI。</p>\n<p>React只是JavaScript，开发者只需学习非常少量的API（一些函数及函数使用方法）来掌握React。掌握JavaScript技能有助于你成为更好的React开发人员，没有入门障碍。一个JavaScript开发者可以在几个小时内成为一个高效的React开发者。</p>\n<p>不仅仅是这些，下面让我们揭开React不断流行背后的更多原因。一个原因是它的Virtual DOM（React的reconciliation 算法)。我们通过一个例子来展示这算法的实际应用价值。</p>\n<p>React的官方定义：<em>用于构建UI的JavaScript库</em>。这个定义强调了两个不同的方面：</p>\n<p>React是一个JavaScript库，不是一个框架。 它并不是一套完整的解决方案，我们需要使用更多其他的库。React并不能取代一套解决方案中的其他角色。它只关注于做好一件事。</p>\n<p>另一方面，React做的很棒的地方：<em>构建UI</em> **：UI使得用户可以与机器进行交互。UI随处可见，小到微波炉上的一个按钮，大到航天器的仪表盘。如果我们要交互的设备可以识别Javascript语言，那么我们就可以使用React来描述它的UI。</p>\n<p>Web浏览器可以识别JavaScript，所以我们可以使用React来描述Web用户界面。我喜欢用<strong>描述</strong>这个词，因为这就是我们用React主要做的事：只需要告诉它我们想要什么，然后React帮我们在Web浏览器中构建出实际的UI。如果没有React或类似的库，我们将不得不使用原生的Web API和JavaScript手动构建用户界面。</p>\n<p>当你听到“React是声明式的”时，没错，就是这样：我们用“React”描述用户界面，告诉它我们想要什么（而不是如何做）。React本身会处理“如何做”，将我们的声明式描述（用React来描述）转换为浏览器中的实际用户界面。使用React，我们可以声明动态数据的HTML页面，而不仅仅是静态数据。</p>\n<p>React有三个主要的设计理念推动了它的流行：</p>\n<h5 id="1">1—可复用，组件化，有状态组件</h5>\n<p>在React中，我们使用组件描述UI。你可以将组件视为简单的函数（任何编程语言中的函数）：我们调用函数时，给定一个输入，它会给我们返回一个输出。我们可以按需复用函数，可以用小的函数组合成更大的函数。</p>\n<p>组件也是一样的，组件的输入被称为“属性（properties）”和“状态（state）”，组件的输出是一个用户界面的描述（就像HTML是对浏览器界面的描述一样）。我们可以在多个用户界面中复用同一个组件，组件也可以包含其他组件。</p>\n<p>但是，与纯函数不同的是，React组件可以有一个私有的状态来保存可能随时间变化的数据。</p>\n<h5 id="2">2 — 响应式更新</h5>\n<p>React，顾名思义，就是这个概念的简单解释。当组件的状态（输入）发生变化时，它所表示的用户界面（输出）也会随之发生变化。对UI的描述发生了变化必然会引起我们交互设备的变化。</p>\n<p>在浏览器中，我们需要在DOM（文档对象模型）中重新生成HTML视图。使用React，我们不需要关心<em>如何</em>反映这些更改，甚至不需要管理<em>何时</em>把更改映射到浏览器中；React会对状态改变做出反应，并在需要时自动更新DOM。</p>\n<h5 id="3">3 — 在内存中视图的虚拟表现</h5>\n<p>使用React，我们用JavaScript编写HTML，使用JavaScript根据数据生成HTML，而不是扩展HTML去反映数据。对HTML进行扩展是其它JavaScript框架通常做的事，例如Angular给HTML扩展了一些特性如循环、条件判断等。</p>\n<p>当我们收到来自服务器的数据（在后台使用AJAX）时，我们需要比HTML更多的东西来对该数据做出响应：要么使用扩展后的HTML（如Angular），要么使用JavaScript来生成HTML。这两种方法各有优劣。React属于后者，并且宣称该方法优胜于劣。</p>\n<p>事实上，react有一个主要的优势使它成为这种方式的良好实践：使用JavaScript来渲染HTML使React能够容易地在内存中保留HTML的虚拟表示（通常称为<em>“虚拟DOM”</em>）。React首先使用虚拟DOM渲染一个虚拟的HTML树，然后，每当一个状态发生改变，我们便得到一个需要更新到浏览器DOM中的新HTML树。但我们不需要把这整个HTML树都更新到浏览器DOM中，而是只需要更新新旧HTML树不同的部分（因为React在内存中保存着新旧两个HTML树），这个过程被称为Tree Reconciliation。我认为，这是自AJAX诞生以来，在Web开发领域中发生的最好的事情！</p>\n<p>在接下来的示例中，将重点介绍最后一个概念，并且可以看到一个简单的Tree Reconciliation过程示例及其所带来的巨大不同。我们将使用两种方式编写相同的HTML示例，首先使用原生Web API和JavaScript编写，然后我们将看到如何使用React描述相同的HTML树。</p>\n<p>为了强调最后一个概念，我们将不使用组件，而是使用JavaScript定时器来模拟状态改变的操作。我们也不会使用JSX，尽管使用JSX会是一段更简洁的代码。我写React时一直使用JSX，但是在这个例子中我直接使用React API，目的是使大家更好地理解这个概念。</p>\n<h4 id="reactreconciliation">React的reconciliation算法示例</h4>\n<p>在开始这个例子之前，你需要一个浏览器和一个编辑器。或者你可以使用在线编码工具。我会使用本地文件并在浏览器中直接测试。（暂不需要web server）。</p>\n<p>我们从头开始这个例子，创建一个新的目录，打开你最喜爱的编辑器：</p>\n<pre><code>mkdir react-demo\ncd react-demo\natom .\n</code></pre>\n<p>在当前目录下创建一个<code>index.html</code>文件，在其中建立一个标准HTML模板。在该模板中引入一个<code>script.js</code>文件，可以在该脚本文件中写一个<code>console.log</code>语句测试一下是否已正确引入。</p>\n<pre><code>&lt;!DOCTYPE html&gt;\n&lt;html&gt;\n  &lt;head&gt;\n    &lt;meta charset="utf-8"&gt;\n    &lt;title&gt;React Demo&lt;/title&gt;\n  &lt;/head&gt;\n  &lt;body&gt;\n    &lt;script src="script.js"&gt;&lt;/script&gt;\n  &lt;/body&gt;\n&lt;/html&gt;\n</code></pre>\n<p>在浏览器中打开<code>index.html</code>文件，确保你可以看到这个空模板，并且可以在控制台看到你在<code>script.js</code>中放置的<code>console.log</code> 测试信息。</p>\n<pre><code>open index.html # On Mac\nexplorer index.html # On Windows\n</code></pre>\n<p>现在，我们来引入React库。可以在<a href="https://facebook.github.io/react/docs/installation.html">React官网</a>中直接复制出react和react-dom脚本地址放在<code>index.html</code>中。</p>\n<pre><code>&lt;script src="https://unpkg.com/react@15/dist/react.js"&gt;&lt;/script&gt;\n&lt;script src="https://unpkg.com/react-dom@15/dist/react-dom.js"&gt;&lt;/script&gt;\n</code></pre>\n<p>之所以引入这两个不同的脚本，是因为<code>React</code>库本身适合在没有浏览器的情况下使用，要在浏览器中使用React，我们需要<code>ReactDOM</code>库。</p>\n<p>我们刷新浏览器，应该可以看到<code>React</code>和<code>ReactDOM</code>全局可用。</p>\n<p>通过这样简单的配置，现在我们可以访问<code>React</code>和<code>ReactDom</code>API。当然，原生的Web API和JavaScript也是可以访问的，我们将首先使用它们。</p>\n<p>我们可以使用原生JavaScript和DOM Web API在浏览器中动态插入HTML。创建一个id为“js”的div元素来放置我们的JavaScript HTML内容。在<code>index.html</code>body元素里script标签的前面，添加：</p>\n<pre><code>&lt;div id="js"&gt;&lt;/div&gt;\n</code></pre>\n<p>然后在<code>script.js</code>中，我们通过id来获取这个新的div元素并把它放到一个常量中，将该常量命名为jsContainer。可以通过<code>document.getElementById</code>从HTML中获取div元素：</p>\n<pre><code>const jsContainer = document.getElementById("js");\n</code></pre>\n<p>我们在div元素上直接调用innerHTML来控制它的内容。调用这个方法可以将任何HTML模板插入到DOM元素中。我们来插入一个class为“demo”的div元素，内容为“Hello JS”字符串：</p>\n<pre><code>jsContainer.innerHTML = `\n  &lt;div class="demo"&gt;\n    Hello JS\n  &lt;/div&gt;\n`;\n</code></pre>\n<p>确保以上可以在浏览器中运行，现在你应该可以在屏幕中看到“Hello JS”。</p>\n<p>到目前为止，这个示例div是我们的用户界面。非常简单的一个。只输出了一串文字给用户看到。</p>\n<p><code>document.getElementById</code> 和 <code>element.innerHTML</code>都属于原生DOM Web API的一部分。这里我们通过使用Web平台支持的API直接和浏览器交流。然而，当我们写React代码时，使用React API，React使用DOM Web API与浏览器进行交流。</p>\n<p>React就像我们和浏览器之间的一个代理，大部分情况下我们只需要和React交流而不是浏览器。当然仍然有些情况是需要我们和浏览器直接交流的，但这种情况较少。</p>\n<p>仍然是之前创建的用户界面，这次我们用React API。再创建一个div元素，id为"react"。在<code>index.html</code>中，<code>div#js</code>的后面，添加：</p>\n<pre><code>&lt;div id="react"&gt;&lt;/div&gt;\n</code></pre>\n<p>然后，在<code>script.js</code>中，为该div创建一个新的常量容器：</p>\n<pre><code>const reactContainer = document.getElementById("react");\n</code></pre>\n<p>这个容器是我们唯一调用原生web API的地方，因为ReactDOM需要知道将我们的应用放在DOM里的哪个位置。</p>\n<p>定义好了react 的容器，现在我们可以用ReactDOM库来将React版本的HTML模板渲染到这一容器里：</p>\n<pre><code>ReactDOM.render(\n  /* TODO: React\'s version of the HTML template */,\n  reactContainer\n)\n</code></pre>\n<p>接下来我们要做的将是你真正理解React库的第一个里程碑。还记得前面说的用React的话我们可以用JavaScript来写HTML吗？这正是接下来我们要做的~</p>\n<p>我们将使用JavaScript调用React API来完成这个简单的HTML用户界面，在这个例子完成之后你会比较直观的明白我们这么做的原因。</p>\n<p>相对于处理字符串（上面我们的原生JavaScript示例是这样做的），用React我们处理的是<em>对象</em>。通过调用<code>React.createElement</code>（React API的核心方法），任何HTML字符串都将被表示为一个对象。</p>\n<p>这是我们用React写的一个与前面等效的HTML用户界面：</p>\n<p><code>\nReactDOM.render(\n    React.createElement(\n      "div",\n      { className: "demo" },\n      "Hello React"\n    ),\n    reactContainer\n  );\n</code></p>\n<p><code>React.createElement</code>接收一些参数：</p>\n<p>第一个参数是HTML标签，在我们的例子中是一个div。</p>\n<p>第二个参数是一个对象，表示我们希望此标签具有的一些属性。为了与前面原生JS示例保持一致，我们用<code>{className:"demo"}</code>,它将被转为<code>class="demo"</code>。注意我们在属性中用的是<code>className</code>而不是<code>class</code> ,因为React是用JavaScript与Web API匹配而不是HTML本身。</p>\n<p>第三个参数是元素的内容。我们在其中放了一个“Hello React”字符串。</p>\n<p>现在我们可以测试一下。浏览器应该显示“Hello JS”和“Hello React”。通过使用样式，我们把示例div显示为一个盒子，便于视觉上的区分。在<code>index.html</code>中：</p>\n<pre><code>&lt;style media="screen"&gt;\n  .demo {\n    border: 1px solid #ccc;\n    margin: 1em;\n    padding: 1em;\n  }\n&lt;/style&gt;\n</code></pre>\n<p>现在我们有两个结点，一个由DOM Web API直接控制，另一个由React API控制。我们在浏览器中构建这两个结点的方式之间唯一的主要区别是，在JS版本中，我们使用一个字符串表示内容，而在React版本中，我们使用原生JavaScript调用，并且内容用一个对象表示而不是一个字符串。</p>\n<p>无论HTML用户界面多么复杂，使用React时，通过调用<code>React.createElement</code>，每个HTML元素都将被表示为一个JavaScript对象。</p>\n<p>现在来为我们简单的用户界面添加更多的功能。添加一个文本框来读取用户的输入。</p>\n<p>要在HTML模板中嵌套元素，在JS版本中可直接嵌入，因为它是HTML。例如，要使示例<code>div</code>渲染一个<code>&lt;input /&gt;</code>元素，我们只需将其添加到其中：</p>\n<pre><code>jsContainer.innerHTML = `\n  &lt;div class="demo"&gt;\n    Hello JS\n    &lt;input /&gt;\n  &lt;/div&gt;\n`;\n</code></pre>\n<p>用React我们可以做到同样的事，通过在<code>React.createElement</code>的第三个参数之后添加更多的参数。为了与原生JS示例保持一致，我们添加第四个参数，该参数是另一个<code>React.createElement</code>的调用，用来渲染一个<code>input</code>元素（记住，每个HTML元素都是一个对象）：</p>\n<pre><code>ReactDOM.render(\n  React.createElement(\n    "div",\n    { className: "demo" },\n    "Hello React",\n    React.createElement("input")\n  ),\n  reactContainer\n);\n</code></pre>\n<p><em>在这一点上，如果您质疑我们正在做什么，并且认为“这使一个简单的过程变得复杂”，那么你是完全正确的！但是我们正在做的事情有一个很好的理由。请继续阅读。</em></p>\n<p>下面继续在两个版本中添加时间戳。在JS版本中，我们将其放在一个段落元素中。可以调用<code>new Date()</code>来显示一个简单的时间戳：</p>\n<pre><code>jsContainer.innerHTML = `\n  &lt;div class="demo"&gt;\n    Hello JS\n    &lt;input /&gt;\n    &lt;p&gt;${new Date()}&lt;/p&gt;\n  &lt;/div&gt;\n`;\n</code></pre>\n<p>在React版本中也添加。在最外层<code>div</code>元素中添加第五个参数。该参数是另一个<code>React.createElement</code>的调用，这次使用一个<code>p</code>标签，不含属性，内容是<code>new Date()</code>的字符串：</p>\n<pre><code>ReactDOM.render(\n  React.createElement(\n    "div",\n    { className: "demo" },\n    "Hello React",\n    React.createElement("input"),\n    React.createElement(\n      "p",\n      null,\n      new Date().toString()\n    )\n  ),\n  reactContainer\n);\n</code></pre>\n<p>JS和React版本仍然在浏览器中呈现完全相同的HTML。</p>\n<p><img src="https://cdn-images-1.medium.com/max/800/1*fLaNHWXUJh4ICEvMXByvwg.png" alt="" /></p>\n<p>正如你所看到的，到目前为止，使用React实际上比使用简单、熟悉的原生方式困难得多。那么是React的什么优点，值得我们放弃熟悉的HTML，还不得不学习一个新的API来编写本可以用HTML轻易编写的内容？答案不在于渲染第一个HTML视图，而在于我们要做什么来更新现有的DOM视图。</p>\n<p>所以，我们来对现有的DOM进行一次更新操作，简单地用时间戳来计时。</p>\n<p>我们可以使用<code>setInterval</code>（Web定时器API） 轻松地在浏览器中重复调用一个JavaScript函数。所以，我们将JS版本和React版本的DOM操作都放在一个函数中，这个函数命名为<code>render</code>，然后在<code>setInterval</code>中调用它使其每秒重复调用一次。</p>\n<p>以下是<code>script.js</code>中完整的最终代码：</p>\n<pre><code>const jsContainer = document.getElementById("js");\nconst reactContainer = document.getElementById("react");\nconst render = () =&gt; {\n  jsContainer.innerHTML = `\n    &lt;div class="demo"&gt;\n      Hello JS\n      &lt;input /&gt;\n      &lt;p&gt;${new Date()}&lt;/p&gt;\n    &lt;/div&gt;\n  `;\n  ReactDOM.render(\n    React.createElement(\n      "div",\n      { className: "demo" },\n      "Hello React ",\n      React.createElement("input"),\n      React.createElement(\n        "p",\n        null,\n        new Date().toString()\n      )\n    ),\n    reactContainer\n  );\n}\nsetInterval(render, 1000);\n</code></pre>\n<p>现在我们刷新浏览器，在两个版本中，时间戳字符串在每秒变化，DOM和用户界面必然也在更新着。</p>\n<p><em>接下来就是React可能让你大吃一惊的时刻。</em> 如果你尝试在JS版本的文本框中输入内容，你将无法进行。这是意料之中的，因为我们基本上是在每秒钟都扔掉整个DOM节点并重新生成。然而，如果你试着在用React渲染的文本框中输入某些内容，便可以做到！</p>\n<p>虽然整个React渲染代码在我们的计时器内，但React只是改变时间戳的那一段落，而不是整个DOM节点。这就是为什么文本输入框没有重新生成且我们可以在其中输入。</p>\n<p>如果在Chrome开发者工具元素面板中检查这两个DOM节点，你可以形象地看到这两种更新DOM的不同方式。Chrome 开发者工具高亮显示任何被更新的HTML元素。你将看到我们是如何在每秒钟重新生成了整个“js”div，而React只是巧妙地重新生成带有时间戳字符串的段落。</p>\n<p><img src="https://cdn-images-1.medium.com/max/800/1*9RGpVv6Mwjl6LApR7vsYqA.gif" alt="Image captured in Chrome" /></p>\n<p>React有一个聪明的diffing算法：通过差异比较，仅对需要更新的DOM节点做重新生成，其余部分保持不变。这个diffing算法可以使用是由于React的虚拟DOM以及在内存中保留了用户界面的表示（因为我们用JavaScript写的）。</p>\n<p>使用虚拟DOM，React在内存中保留上一个DOM版本，当一个新的DOM版本需要更新到浏览器中时，这一新的版本也存在内存中，因此React可以计算新旧版本的差异（在我们的例子中，这个差异是时间戳段落）。</p>\n<p>然后React会指示浏览器只更新计算出的差异，而不是整个DOM节点。无论我们重新生成用户界面多少次，React都仅让浏览器“部分”更新。</p>\n<p>这种方法不仅非常高效，而且大量减少了我们思考更新用户界面方式的复杂性。有了React来做所有关于我们是否应该更新DOM的计算，使我们能够专注于思考数据（状态）和描述用户界面的方式。</p>\n<p>然后，我们只需要根据需求来管理数据更新，而不用关心如何将这些更新反映到浏览器的用户界面中（因为我们知道React会做到这一点，而且是以一种有效的方式做到这一点）！</p>\n<p>谢谢阅读！你可以在<a href="https://github.com/jscomplete/react-virtual-dom-demo/tree/master/demo">这里</a>查看以上demo的源代码，可以在<a href="https://jscomplete.github.io/react-virtual-dom-demo/demo/">这里</a>看demo演示。</p>\n<p>如果您对本文或我写的其他文章有任何疑问，请在<a href="https://slack.jscomplete.com/">此闲置帐户</a>中联系我（您可以邀请自己）并在#questions频道询问。</p>\n<p>我为<a href="https://www.pluralsight.com/search?q=samer+buna&categories=course">Pluralsight</a>和<a href="https://www.lynda.com/Samer-Buna/7060467-1.html">Lynda</a>创建了在线课程。我最近的课程有<a href="https://www.pluralsight.com/courses/react-js-getting-started">React.js入门</a>，<a href="https://www.pluralsight.com/courses/nodejs-advanced">高级Node.js</a>和<a href="https://www.lynda.com/Express-js-tutorials/Learning-Full-Stack-JavaScript-Development-MongoDB-Node-React/533304-2.html">学习全栈JavaScript</a>。</p>\n<blockquote>\n  <p>原文链接<a href="https://medium.freecodecamp.com/yes-react-is-taking-over-front-end-development-the-question-is-why-40837af8ab76">https://medium.freecodecamp.com/yes-react-is-taking-over-front-end-development-the-question-is-why-40837af8ab76</a></p>\n</blockquote>'}});